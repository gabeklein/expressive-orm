import knex, { Knex } from 'knex';

import { Field } from './Field';
import { isTypeConstructor, Type } from './Type';

export const RelevantTable = new WeakMap<{}, Query.Table>();

declare const ENTITY: unique symbol;
declare const JOIN: unique symbol;

declare namespace Query { 
  interface Where {
    /**
     * Accepts instructions for nesting in a parenthesis.
     * When only one group of instructions is provided, the statement are separated by OR.
     **/
    (orWhere: Instructions): Instruction;

    /**
     * Accepts instructions for nesting in a parenthesis.
     * 
     * When multiple groups of instructions are provided, the groups
     * are separated by OR and nested comparisons are separated by AND.
     */
    (...orWhere: Instructions[]): Instruction;
  
    /** Create a reference to the primary table, returned object can be used to query against that table. */
    <T extends Type>(entity: Type.EntityType<T>): From<T>;
  
    /** Registers a type as a inner join. */
    <T extends Type>(entity: Type.EntityType<T>, on: Join.On<T>, join?: "inner"): Join<T>;

    /** Registers a type as a left join, returned object has optional properties which may be undefined where the join is not present. */
    <T extends Type>(entity: Type.EntityType<T>, on: Join.On<T>, join: Join.Mode): LeftJoin<T>;

    /** Prepares write operations for a particular table. */
    <T extends Type>(field: From<T>): Verbs<T>;
    
    /** Prepare comparison against a particilar field, returns operations for the given type. */
    <T>(field: T): Assert<T>;
  }

  type From<T extends Type = Type> = {
    [K in Type.Field<T>]: Exclude<T[K], null>;
  } & {
    [ENTITY]?: T
  }

  namespace Join {
    type Mode = "left" | "inner";

    type Where = (field: Field) => {
      is(equalTo: Field): void;
      isNot(equalTo: Field): void;
      isMore(than: Field): void;
      isLess(than: Field): void;
    }

    type Function = (on: Where) => void;

    type Object<T extends Type> = {
      [K in Type.Field<T>]?: T[K];
    }

    type On<T extends Type = any> = Object<T> | Function;
  }

  type Join<T extends Type> = From<T> & {
    [JOIN]?: "inner"
  };

  type LeftJoin<T extends Type> = Compat<T> & {
    [ENTITY]?: T
    [JOIN]?: "left"
  }

  /** A query instruction returned by assertions which can be nested. */
  type Instruction = (or?: boolean) => void;

  /** A group of query instructions declared within parenthesis. */
  type Instructions  = Instruction[];

  interface Compare<T> {
    is(equalTo: T): Instruction;
    isNot(equalTo: T): Instruction;
    isMore(than: T): Instruction;
    isLess(than: T): Instruction;
  }

  interface Assert<T> extends Compare<T> {
    isAsc(): void;
    isDesc(): void;
  }

  interface Verbs <T extends Type> {
    delete(): void;
    update(values: Query.Update<T>): void;
  }

  interface Table {
    type: Type.EntityType;
    name: string | Knex.AliasDict;
    alias?: string;
  }

  type Compat<T extends Type = Type> = {
    [K in Type.Field<T>]?: T[K];
  }

  // TODO: make this default/nullable aware.
  type Update<T extends Type> = {
    [K in Type.Field<T>]?: Exclude<T[K], undefined>;
  }

  type Function<R> = (where: Where) => R;
}

interface Query<T = unknown> extends PromiseLike<T> {
  /**
   * Returns the SQL string generated by this query.
   */
  toString(): string;
}

interface SelectQuery<T = unknown> extends Query<T[]> {
  /**
   * Counts the number of rows that would be selected.
   **/
  count(): Promise<number>;

  /**
   * Returns the first row that matches creteria.
   * 
   * @param orFail If true, will throw an error if no results are returned.
   */
  one(orFail?: boolean): Promise<T>;
}

/** Executable query on whole types. */
interface TypeQuery<T extends Type = any> extends SelectQuery<T> {}

function Query<T extends Type>(from: Query.Function<Query.From<T>>): TypeQuery<T>;

function Query<T extends {}>(from: Query.Function<T>): SelectQuery<T>;

/**
 * Creates a new query.
 * 
 * If no selection is returned by the constructor, will return
 * the number of rows that would be selected or modified.
 */
function Query(from: Query.Function<void>): Query<number>;

function Query<T = void>(constructor: Query.Function<T>): Query | SelectQuery | TypeQuery {
  const tables = [] as Query.Table[];
  const pending = new Set<Query.Instruction>();

  let parse: ((raw: any[]) => any[]) | undefined;
  let builder!: Knex.QueryBuilder;
  let main: Type.EntityType;

  let currentTarget: Knex.QueryBuilder = builder;

  const selects = constructor(where as any);
  const query: Query = {
    then(resolve: (res: any) => any, reject: (err: any) => any){
      const execute = parse ? builder.then(parse) : builder;
      return execute.then<T[]>(resolve).catch(reject);
    },
    toString(){
      return builder.toString().replace(/```/g, "`");
    }
  }

  pending.forEach(fn => fn());
  pending.clear();

  if(!selects){
    builder.count();
    return query;
  }
  
  if(Field.is(selects)){
    const name = selects.column;

    builder.select({ [name]: String(selects) });
  
    parse = raw => raw.map(({ [name]: value }) => (
      selects.get ? selects.get(value) : value
    ));
  }
  else if(typeof selects == "object")
    map(selects)

  return <SelectQuery> {
    ...query,
    count(){
      return builder.clone().clearSelect().count();
    },
    async one(orFail?: boolean){
      const execute = builder.clone().limit(1) as Promise<any>;
      const res = await (parse ? execute.then(parse) : execute);
  
      if(res.length == 0 && orFail)
        throw new Error("Query returned no results.");
  
      return res[0] as T;
    }
  }

  function where(
    type: unknown,
    on?: Query.Join.On<any>,
    join?: Query.Join.Mode
  ): any {
    if(isTypeConstructor(type)){
      if(typeof on == "string")
        throw new Error("Bad parameters.");

      return table(type, on, join);
    }

    if(Field.is(type))
      return {
        is: compare(type, "="),
        isNot: compare(type, "<>"),
        isMore: compare(type, ">"),
        isLess: compare(type, "<"),
        isAsc: order(type, "asc"),
        isDesc: order(type, "desc"),
      }

    if(Array.isArray(type))
        return parens([...arguments])

    if(isFromType(type)){
      const table = RelevantTable.get(type);
  
      if(!table)
        throw new Error(`Argument ${type} is not a query entity.`);
  
      return <Query.Verbs<Type>>{
        delete: () => {
          builder.table(table.name).delete();
        },
        update: (data: Query.Update<any>) => {
          data = table.type.digest(data);
          builder.table(table.name).update(data);
        }
      }
    }

    throw new Error("Invalid query.");
  }

  function parens(args: Query.Instructions[]){
    for(const group of args)
      for(const fn of group)
        pending.delete(fn);

    function apply(){
      const orGroup = args.length > 1;
      const current = currentTarget;

      args.forEach((group, i) => {
        currentTarget[i > 0 ? "orWhere" : "where"](context => {
          currentTarget = context;
          group.forEach(fn => fn(!orGroup));
          currentTarget = current;
        })
      });
    }

    pending.add(apply);

    return apply;
  }

  function compare(type: Field, op: string) {
    return (right: unknown) => {
      function apply(or?: boolean) {
        const r = typeof right === "number" ? right : String(right);
        currentTarget[or ? "orWhere" : "where"](String(type), op, r);
      }

      pending.add(apply);

      return apply;
    };
  }

  function map(selects: NonNullable<T>){
    const output = new Map<string | Field, string | number>();

    Object.getOwnPropertyNames(selects).forEach(key => {
      const value = (selects as any)[key];
    
      if(Field.is(value)){
        output.set(value, key);
        builder.select({ [key]: String(value) });
      }
    })

    parse = raw => raw.map(row => {
      const values = Object.create(selects as {});
    
      output.forEach((column, value) => {
        if(Field.is(value) && value.get)
          value = value.get(row[column]);

        Object.defineProperty(values, column, { value });
      })
        
      return values as T;
    })
  }

  function order(by: Field, direction: "asc" | "desc"){
    return () => {
      builder.orderBy(String(by), direction);
    }
  }

  function table(
    type: Type.EntityType,
    on?: Query.Join.On<any>,
    mode?: Query.Join.Mode
  ): Query.From {
    let { fields, schema } = type;
    let name: string | Knex.AliasDict = type.table
    let alias: string | undefined;

    if(schema){
      alias = `$${tables.length}`;
      name = { [alias]: schema + '.' + name };
    }

    const proxy = {} as any;
    const metadata: Query.Table = { name, alias, type };

    tables.push(metadata);
    RelevantTable.set(proxy, metadata);

    fields.forEach((field, key) => {
      field = Object.create(field);
      RelevantTable.set(field, metadata);
      Object.defineProperty(proxy, key, { value: field })
    })

    if(main === undefined){
      const engine = type.connection?.knex || knex({
        client: "sqlite3",
        useNullAsDefault: true,
        pool: { max: 0 }
      });

      main = type;
      builder = currentTarget = engine(name)
    }
    else {
      if(type.connection !== main.connection)
        throw new Error(`Joined entity ${type} does not share a connection with ${main}`);

      let callback: Knex.JoinCallback;

      switch(typeof on){
        case "function":
          callback = (table) => {
            pending.add(() => {
              on(field => {
                if (!Field.is(field))
                  throw new Error("Join assertions can only apply to fields.");

                const on = (op: string) => (right: Field) => {
                  table.on(String(field), op, String(right));
                };

                return {
                  is: on("="),
                  isNot: on("<>"),
                  isMore: on(">"),
                  isLess: on("<"),
                }
              });
            })
          }
        break;

        case "object":
          callback = (table) => {
            for (const key in on) {
              const field = fields.get(key);
    
              if (!field)
                throw new Error(`${key} is not a valid field in ${type}.`);
    
              const left = `${type.table}.${field.column}`;
              const right = String(on[key]);
    
              table.on(left, "=", right);
            }
          }
        break;

        default:
          throw new Error(`Invalid join on: ${on}`);
      }

      switch(mode){
        case "inner":
        case undefined:
          builder.join(name, callback);
          break;

        case "left":
          builder.leftJoin(name, callback);
          break;
  
        case "right" as unknown:
        case "full" as unknown:
          throw new Error(`Cannot ${mode} join because that would affect ${main} which is already defined.`);
  
        default:
          throw new Error(`Invalid join type ${mode}.`);
      }
    }

    return proxy;
  }
}

Query.one = function one<T extends {}>(
  where: Query.Function<T>, orFail?: boolean){

  return Query(where).one(orFail);
}

function isFromType(type: any): type is Query.From {
  return RelevantTable.has(type);
}

export { Query, SelectQuery, TypeQuery };