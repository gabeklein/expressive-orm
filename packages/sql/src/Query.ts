import knex, { Knex } from 'knex';

import { Field } from './Field';
import { isTypeConstructor, Type } from './Type';

export const RelevantTable = new WeakMap<{}, Query.Table>();
declare const ENTITY: unique symbol;

declare namespace Query { 
  namespace Join {
    type Mode = "left" | "inner";

    type Where = <T>(field: T) => Assert<T>;

    type Function<R = Mode> = (on: Where) => R | void;

    type Object<T extends Type> = {
      [K in Type.Field<T>]?: T[K];
    }
  }

  interface Assert<T> {
    is(equalTo: T): void;
    isNot(equalTo: T): void;
    isMore(than: T): void;
    isLess(than: T): void;
    isAsc(): void;
    isDesc(): void;
  }

  interface Verbs <T extends Type> {
    delete(): void;
    update(values: Query.Update<T>): void;
  }

  type Cond<T = unknown> = {
    left: Field | T,
    right: Field | T,
    operator: string
  }

  interface Table {
    type: Type.EntityType;
    name: string | Knex.AliasDict;
    alias?: string;
  }

  type FromType<T extends Type = Type> = {
    [K in Type.Field<T>]: Exclude<T[K], null>;
  } & {
    [ENTITY]?: T
  }

  type Compare<T extends Type = Type> = {
    [K in Type.Field<T>]?: T[K];
  }

  // TODO: make this default/nullable aware.
  type Update<T extends Type> = {
    [K in Type.Field<T>]?: Exclude<T[K], undefined>;
  }

  type Function<R> = (where: Callback) => R;

  interface Callback {
    <T extends Type>(entity: Type.EntityType<T>): FromType<T>;

    <T extends Type>(entity: Type.EntityType<T>, on: Join.Function<"inner" | void>): FromType<T>;
    <T extends Type>(entity: Type.EntityType<T>, on: Join.Function<Join.Mode>): Partial<FromType<T>>;
    
    <T extends Type>(entity: Type.EntityType<T>, on: Compare<T>, join?: "inner"): FromType<T>;
    <T extends Type>(entity: Type.EntityType<T>, on: Compare<T>, join: Join.Mode): Partial<FromType<T>>;

    <T extends Type>(field: FromType<T>): Verbs<T>;
    
    <T>(field: T): Assert<T>;
  }
}

interface Query<T = unknown> extends PromiseLike<T> {
  /**
   * Counts the number of rows that would be selected or modified.
   * Will ignore any side effects, such as update and delete.
   **/
  count(): Promise<number>;

  /**
   * Returns the SQL string generated by this query.
   */
  toString(): string;
}

interface VoidQuery extends Query<number> {}

interface SelectQuery<T = unknown> extends Query<T[]> {
  /**
   * Returns the first row that matches creteria.
   * 
   * @param orFail If true, will throw an error if no results are returned.
   */
  one(orFail?: boolean): Promise<T>;
}

/** Executable query on whole types. */
interface TypeQuery<T extends Type = any> extends SelectQuery<T> {
  update(values: Type.Insert<T>): Promise<number>;
  delete(): Promise<number>;
}

function Query<T extends Type>(from: Query.Function<T>): TypeQuery<T>;

function Query<T extends {}>(from: Query.Function<T>): SelectQuery<T>;

/**
 * Creates a new query.
 * 
 * If no selection is returned by the constructor, will return
 * the number of rows that would be selected or modified.
 */
function Query(from: Query.Function<void>): VoidQuery;

function Query<T = void>(constructor: Query.Function<T>): Query | SelectQuery | TypeQuery {
  const tables = [] as Query.Table[];
  const pending = new Set<() => void>();

  let parse = (raw: unknown[]) => raw;
  let builder!: Knex.QueryBuilder;
  let main: Type.EntityType;

  const selects = constructor(where);

  pending.forEach(fn => fn());
  pending.clear();

  if(selects){
    builder.clearSelect();

    if(Field.is(selects)){
      builder.select({
        [selects.column]: String(selects)
      });
  
      parse = raw => raw.map(row => {
        const value = (row as any)[selects.column];
        return selects.get ? selects.get(value) : value;
      });
    }
    else if(typeof selects == "object"){
      const output = new Map<string | Field, string | number>();

      Object.getOwnPropertyNames(selects).forEach(key => {
        const value = (selects as any)[key];
    
        if(Field.is(value)){
          output.set(value, key);
          builder.select({ [key]: String(value) });
        }
      })

      parse = raw => raw.map(row => {
        const values = Object.create(selects as {});
    
        output.forEach((column, value) => {
          if(Field.is(value) && value.get)
            value = value.get((row as any)[column]);

          Object.defineProperty(values, column, { value });
        })
        
        return values as T;
      })
    }
  }

  function where(
    type: unknown,
    on?: Query.Compare | Query.Join.Function<any>,
    join?: Query.Join.Mode
  ): any {
    if(isTypeConstructor(type)){
      if(typeof on == "string")
        throw new Error("Bad parameters.");

      return table(type, on, join);
    }

    if(Field.is(type))
      return assert(type, (left, op, right) => {
        builder.where(left, op, right);
      });

    if(isFromType(type))
      return verbs(type);

    throw new Error("Invalid query.");
  }

  function assert<T = any>(
    field: Field,
    compare: (left: string, op: string, right: any) => void
  ): Query.Assert<T> {
    const ref = String(field);

    return {
      is: val => compare(ref, "=", val),
      isNot: val => compare(ref, "<>", val),
      isMore: val => compare(ref, ">", val),
      isLess: val => compare(ref, "<", val),
      isAsc: () => builder.orderBy(ref, "asc"),
      isDesc: () => builder.orderBy(ref, "desc"),
    }
  }

  function verbs<T extends Type>(from: Query.FromType<T>): Query.Verbs<T> {
    const table = RelevantTable.get(from);

    if(!table)
      throw new Error(`Argument ${from} is not a query entity.`);

    return {
      delete: () => {
        builder.table(table.name).delete();
      },
      update: (data: Query.Update<any>) => {
        data = table.type.digest(data);
        builder.table(table.name).update(data);
      }
    }
  }

  function table(
    type: Type.EntityType,
    on?: Query.Compare | Query.Join.Function,
    mode?: Query.Join.Mode
  ): Query.FromType {
    let { fields, schema } = type;
    let name: string | Knex.AliasDict = type.table
    let alias: string | undefined;

    if(schema){
      alias = `$${tables.length}`;
      name = { [alias]: schema + '.' + name };
    }

    const proxy = {} as any;
    const metadata: Query.Table = { name, alias, type };

    tables.push(metadata);
    RelevantTable.set(proxy, metadata);

    fields.forEach((field, key) => {
      field = Object.create(field);
      RelevantTable.set(field, metadata);
      Object.defineProperty(proxy, key, { value: field })
    })

    if(main === undefined){
      main = type;

      const engine = type.connection?.knex || knex({
        client: "sqlite3",
        useNullAsDefault: true,
        pool: { max: 0 }
      });

      builder = engine(name).select({ count: "COUNT(*)" });;
    }
    else if(type.connection !== main.connection)
      throw new Error(`Joined entity ${type} does not share a connection with ${main}`);
    else
      join(metadata, on, mode)

    return proxy;
  }

  function join(
    metadata: Query.Table,
    on?: Query.Compare | Query.Join.Function,
    mode?: Query.Join.Mode
  ){
    const { name, type } = metadata;

    let callback: Knex.JoinCallback;

    if(typeof on == "function")
      callback = table => {
        pending.add(() => {
          on(field => {
            if (Field.is(field))
              return assert(field, (left, op, right) => {
                table.on(left, op, right.toString());
              });
            else
              throw new Error("Join assertions can only apply to fields.");
          });
        })
      }
    else if(typeof on == "object")
      callback = table => {
        for (const key in on) {
          const field = type.fields.get(key);

          if (!field)
            throw new Error(`${key} is not a valid field in ${type}.`);

          const left = `${type.table}.${field.column}`;
          const right = String((on as any)[key]);

          table.on(left, "=", right);
        }
      }
    else
      throw new Error(`Invalid join on: ${on}`);
    
    switch(mode){
      case "left":
        builder.leftJoin(name, callback);
        break;

      case "inner":
      case undefined:
        builder.join(name, callback);
        break;

      case "right" as unknown:
      case "full" as unknown:
        throw new Error(`Cannot ${mode} join because that would affect ${main} which is already defined.`);

      default:
        throw new Error(`Invalid join type ${mode}.`);
    }
  }

  const query: Query = {
    then(resolve: (res: any) => any, reject: (err: any) => any){
      return builder.then(parse).then<T[]>(resolve).catch(reject);
    },
    count(){
      return builder.clone().clearSelect().count();
    },
    toString(){
      return builder.toString().replace(/```/g, "`");
    }
  }

  if(selects)
    return {
      ...query,
      async one(orFail?: boolean){
        const res = await builder.clone().limit(1).then(parse);
    
        if(res.length == 0 && orFail)
          throw new Error("Query returned no results.");
    
        return res[0] as T;
      }
    }

  return query;
}

Query.one = function one<T extends {}>(
  where: Query.Function<T>, orFail?: boolean){

  return Query(where).one(orFail);
}

function isFromType(type: any): type is Query.FromType {
  return RelevantTable.has(type);
}

export { Query }